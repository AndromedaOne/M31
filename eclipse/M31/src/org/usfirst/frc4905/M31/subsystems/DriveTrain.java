// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4905.M31.subsystems;

import org.usfirst.frc4905.M31.RobotMap;
import org.usfirst.frc4905.M31.commands.*;
import org.usfirst.frc4905.M31.OI;
import Utilities.*;

import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;
import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class DriveTrain extends Subsystem {	
	


	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final CANTalon frontLeft = RobotMap.driveTrainFrontLeft;
	private final CANTalon backRight = RobotMap.driveTrainBackRight;
	private final CANTalon frontRight = RobotMap.driveTrainFrontRight;
	private final CANTalon backLeft = RobotMap.driveTrainBackLeft;
	private final RobotDrive robotDrive = RobotMap.driveTrainRobotDrive;
	private final SpeedController climber = RobotMap.driveTrainClimber;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	private final CANTalon m_motors[] = {frontLeft, backRight, frontRight, backLeft};
	
	private int m_iterationsSinceRotationCommanded = 0;
	private double m_desiredHeading;
	
	public DriveTrain() {
		int i;
		for (i = 0; i < m_motors.length; i++) {
			m_motors[i].reverseSensor(false);
			m_motors[i].setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Absolute);
			m_motors[i].setPosition(0);
			m_motors[i].configPeakOutputVoltage(12.0, -12.0);
			m_motors[i].enableBrakeMode(true);
			m_motors[i].setVoltageRampRate(48);
		}
		GyroPIDoutput gyroPIDoutPut = new GyroPIDoutput();
		RobotMap.getNavxGyro().initializeGyroPID(gyroPIDoutPut);
		UltrasonicPIDOutput ultraPIDOutput= new UltrasonicPIDOutput();
		RobotMap.getUltrasonicSubsystem().intializeUltrasonicPID(ultraPIDOutput);

		initializeEncoderPID(500);
	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new TeleopDrive());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void teleopDrive(double xIn, double yIn, double rotation){
		// Greatest Regards to 1519
		// update count of iterations since rotation last commanded
		if ((-0.01 < rotation) && (rotation < 0.01)) {
			// rotation is practically zero, so just set it to zero and
			// increment iterations
			rotation = 0.0;
			m_iterationsSinceRotationCommanded++;
		} else {
			// rotation is being commanded, so clear iteration counter
			m_iterationsSinceRotationCommanded = 0;
		}
		// preserve heading when recently stopped commanding rotations
		if (m_iterationsSinceRotationCommanded == 5) {
			m_desiredHeading = RobotMap.getNavxGyro().getRobotAngle();
		} else if (m_iterationsSinceRotationCommanded > 5) {
			rotation = (m_desiredHeading - RobotMap.getNavxGyro().getRobotAngle()) / 40.0;
		}
		
		robotDrive.mecanumDrive_Cartesian(xIn, yIn, rotation, 0);
	}

		
	public void stop(){
		frontLeft.set(0);
		frontRight.set(0);
		backLeft.set(0);
		backRight.set(0);
	}

	public void getEncPos(){

		System.out.println("Back Left Pos:" +backLeft.getPosition());
		System.out.println("Back Right Pos:" + backRight.getPosition());
		System.out.println("Front Right Pos:" + frontRight.getPosition());
		System.out.println("Front Left Pos:" + frontLeft.getPosition());
	}

	public void resetEncPos(){
		backLeft.setPosition(0);
		backRight.setPosition(0);
		frontRight.setPosition(0);
		frontLeft.setPosition(0);


	}
	public double getEncoderDistance(){
		double sum = 0;
		sum += Math.abs(backLeft.getPosition());
		sum += Math.abs(backRight.getPosition());
		sum += Math.abs(frontLeft.getPosition());
		sum += Math.abs(frontRight.getPosition());
		return sum;

	}
	
	public double getEncoderPosition() {
		return (frontLeft.getPosition() + backLeft.getPosition()
		- frontRight.getPosition() - backRight.getPosition()) / 4;
	}
	
	public void displayEncoderPosition() {
		SmartDashboard.putNumber("Encoder Value", getEncoderPosition());
	}

	private double raiseOutputAboveMin(double output) {
		if((Math.abs(output) < 0.03) && (output != 0)) {
			double minVal = 0.03; 
			if(output < 0) {
				output = -minVal;
			} else {
				output = minVal;				
			}
		}
		return output;
	}
	
	// Encoder PID code

	// Encoder PID controller
	private PIDController m_encoderPID;
	// Encoder PID controller variables
	private static final double encoderKp = 0.0003;
	private static final double encoderKi = 0.000;
	private static final double encoderKd = 0.000;
	private static final double encoderKf = 0.000;
	private static final double encoderTolerance = 100.0;
	private static final double encoderOutputMax = 0.5;

	public PIDController getPIDcontroller() {
		return m_encoderPID;
	}

	private class EncoderPIDin implements PIDSource {

		@Override
		public void setPIDSourceType(PIDSourceType pidSource) {


		}

		@Override
		public PIDSourceType getPIDSourceType() {
			return PIDSourceType.kDisplacement;
		}

		@Override
		public double pidGet() {
			System.out.println("Encoder Position = " + getEncoderPosition());
			return getEncoderPosition();
		}

	}

	private class EncoderPIDout implements PIDOutput {

		@Override
		public void pidWrite(double output) {
			output = raiseOutputAboveMin(output);
			robotDrive.mecanumDrive_Cartesian(0, -output, 0, RobotMap.getNavxGyro().getRobotAngle());
			System.out.println("Encoder Output = " + output 
					+ " Average Error = " + m_encoderPID.getAvgError());

		}

	}


	public void initializeEncoderPID(double distanceToMove) {
		resetEncPos();
		EncoderPIDin encoderPIDin = new EncoderPIDin();
		EncoderPIDout encoderPIDout = new EncoderPIDout();
		m_encoderPID = new PIDController(encoderKp, encoderKi, 
				encoderKd, encoderKf, encoderPIDin, encoderPIDout);
		m_encoderPID.setOutputRange(-encoderOutputMax, encoderOutputMax);
		m_encoderPID.setAbsoluteTolerance(encoderTolerance);
		LiveWindow.addActuator("DriveTrain", "EncoderPID", m_encoderPID);
	}

	public void moveWithEncoderPID(double DistanceToMove) {
		m_encoderPID.setSetpoint(DistanceToMove);
		m_encoderPID.enable();
	}

	public boolean isDoneEncoderPID() {
		System.out.println("encoder distance = " + getEncoderPosition());
		return m_encoderPID.onTarget();
	}

	public void stopEncoderPID() {
		m_encoderPID.disable();

	}


	
	// Gyro PID code 
	private class GyroPIDoutput implements PIDOutput {

		@Override
		public void pidWrite(double output) {
			output = raiseOutputAboveMin(output);
			robotDrive.mecanumDrive_Cartesian(0, 0, output, 0);
		}

	}
	
	public void initializeGyroPID(double deltaAngle) {
		GyroPIDoutput gyroPIDout = new GyroPIDoutput();
		RobotMap.getNavxGyro().initializeGyroPID(gyroPIDout);
		RobotMap.getNavxGyro().turnWithGyroPID(deltaAngle);
	}
	
	public boolean doneTurningWithGyro() {
		// TODO Auto-generated method stub
		return RobotMap.getNavxGyro().isDoneGyroPID();
	}

	public void stopGyroPID() {
		RobotMap.getNavxGyro().stopGyroPID();
	} 

	public double getRobotAngle() {
		return RobotMap.getNavxGyro().getRobotAngle();
	}
	
	public double initializeTurnToCompass(double angle) {
		double initialAngle = Robot.driveTrain.getRobotAngle();
		double angleMod = initialAngle % 360;
		System.out.println("AngleMod = " + angleMod + 
				" Initial Angle = " + initialAngle);
		if(angleMod < 0) {
			//Correcting Negative Modulus
			angleMod = angleMod + 360; 
		}
		double deltaAngle = angle - angleMod;
		if(Math.abs(deltaAngle) > 180) { 
			// Turn to the minimal angle
			boolean neg = (deltaAngle < 0);
			 deltaAngle = Math.abs(deltaAngle) - 360;
			 if(neg) {
				 deltaAngle = -deltaAngle;
			 }
		}
		System.out.println("Delta = " + deltaAngle);
		return deltaAngle;
	}
	
	

	// End of Gyro PID Code

	public void moveInAuto(double sideways, double forward){

		robotDrive.mecanumDrive_Cartesian(sideways, forward, 0, 0);

	}
	public boolean isDoneAuto(double target, double currentPos){
		if(currentPos <  target){
			return false;
		}else{
			return true;
		}
	}

	// UltrasonnicPID code
	private class UltrasonicPIDOutput implements PIDOutput {

		@Override
		public void pidWrite(double output) {
			SmartDashboard.putNumber("Output", output);
			SmartDashboard.putNumber("Distance",
					RobotMap.getUltrasonicSubsystem().getUltrasonicDistance());
			robotDrive.mecanumDrive_Cartesian(output, 0, 0, 0);

		}
	}

	public void intializeUltrasonicPID(double distanceToDriveTo) {
		UltrasonicPIDOutput ultraPIDOutput= new UltrasonicPIDOutput();
		RobotMap.getUltrasonicSubsystem().intializeUltrasonicPID(ultraPIDOutput);
		RobotMap.getUltrasonicSubsystem().moveWithUltrasonicPID(distanceToDriveTo);

	}

	public boolean doneMovingWithUltrasoncPID() {
		return RobotMap.getUltrasonicSubsystem().doneUltrasonicPID();
	}

	public void stopUltrasonicPID() {
		RobotMap.getUltrasonicSubsystem().stopUltrasonicPID();

	}
}

